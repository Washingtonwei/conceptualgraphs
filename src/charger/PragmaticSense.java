package charger;import static charger.FileFormat.UNKNOWN;/*    CharGer - Conceptual Graph Editor Copyright reserved 1998-2014 by Harry S. Delugach         This package is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. This package is  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A  PARTICULAR PURPOSE. See the GNU Lesser General Public License for more  details. You should have received a copy of the GNU Lesser General Public License along with this package; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA *//** * An encapsulation of the notion of a graph's pragmatic sense; i.e., * what is its purpose or intent. * A graph may be a canonical graph, a definition, etc. * CharGer has a few pre-defined purposes that are built-in if a user wants * them. To turn them off, use the Preferences Window. As of Charger 4, this has * been re-purposed to be graph pragmatics. * * @author Harry S. Delugach ( delugach@uah.edu ) Copyright reserved 1998-2014  */public enum PragmaticSense {    /** Defines syntax for canonical graphs. */    CANON( "CANON", "Canonical graph", "Defines syntax for canonical graphs" ),    /** Defines a concept or relation definition. */    DEF( "DEF", "Definition", "Defines a concept or relation definition" ),    /** Declares an observed or assumed fact. */    FACT( "FACT", "Fact", "Declares an observed or assumed fact"),    /** A generic graph, with no particular pragmatic intent. */    GEN( "GEN", "Generic", "A generic graph, with no particular pragmatic intent"),    /** Contains a type or relation hierarchy. */    HIER( "HIER", "Hierarchy", "Contains a type or relation hierarchy"),    /** Contains a query to be resolved through inference. */    QUERY( "QUERY", "Query", "Contains a query to be resolved through inference"),    /** A rewrite or transformation rule. */    RULE( "RULE", "Rule", "A rewrite or transformation rule" ),    /** Represents a schema of plausible or usual knowledge. */    SCHEMA( "SCHEMA", "SChema", "Represents a schema of plausible or usual knowledge" ),    /** not a known pragmatic sense. */    NONE( "NONE", "Unknown", "not a known pragmatic sense" );    private String abbr;    private String label;    private String definition;    private PragmaticSense( String abbr, String label, String definition ) {        this.abbr = abbr;        this.label = label;        this.definition = definition;    }        /**     * What is the abbreviation for this sense?     * @return      */    public String abbr() {        return abbr;    }        public String label() {        return label;    }        public String definition() {        return definition;    }            /**     * @param s a label or abbreviation     * @return the PragmaticSense value corresponding to the extension or description; NONE if none is found.     */    public static PragmaticSense SenseOf( String s ) {        for ( PragmaticSense f : PragmaticSense.values() ) {            if ( f.label().equalsIgnoreCase( s ) ) {                return f;            }            if ( f.abbr().equalsIgnoreCase( s ) ) {                return f;            }        }        return NONE;    }}