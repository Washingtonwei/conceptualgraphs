package charger.act;import charger.*;import charger.EditingChangeState.EditChange;import charger.obj.*;import charger.exception.*;import java.io.File;import java.util.*;import java.text.*;/* 	$Header$ *//*    CharGer - Conceptual Graph Editor    Copyright reserved 1998-2014 by Harry S. Delugach            This package is free software; you can redistribute it and/or modify    it under the terms of the GNU Lesser General Public License as    published by the Free Software Foundation; either version 2.1 of the    License, or (at your option) any later version. This package is     distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;     without even the implied warranty of MERCHANTABILITY or FITNESS FOR A     PARTICULAR PURPOSE. See the GNU Lesser General Public License for more     details. You should have received a copy of the GNU Lesser General Public    License along with this package; if not, write to the Free Software    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA*//**    Contains (mostly static) methods to implement actor primitive operations.	Developers are encouraged to use the plug-in interface ActorPlugin for non-primitive actors.    TO ADD A PRIMITIVE ACTOR TO THE SYSTEM, do the following:    <ul>    <li>create its executable code method in the ActorPrimitive class. Give it some name.	    Executable code method must call GraphUpdater#updateGNode on any changed outputs.	    Executable code should deal with inputs/outputs whose value is "null" meaning _|_   <li>insert a call to its primitive function in the ActorPrimitive#performActorOperation   <li>insert code to construct an input-output signature in GraphUpdater#registerPrimitives    <li>insert a test in the GraphUpdater#isExecutable    </ul>        @see GraphUpdater#updateGNode     @see ActorPrimitive#performActorOperation    @see GraphUpdater#registerPrimitives	@see ActorPlugin    @author Harry S. Delugach ( delugach@uah.edu ) Copyright reserved 1998-2014 by Harry S. Delugach 	If an actor's input or output concepts have distinct types, then numbering may not strictly 	be necessary. Numbers are really only required if there might be ambiguity in either input or output ordering.  */public class ActorPrimitive{		/**			Calculates the output nodes' referents from the input nodes' referents.			Assumes that inputs and outputs are well-formed (i.e., verified against the registry)			@param gu The updater whose thread should be executing our update			@param actorName Label from actual actor that appears in graph.			@param inputs The list of input concepts that appear.			@param outputs The list of output concepts that appear.		 */	public static void performActorOperation( 		GraphUpdater gu, String actorName, ArrayList inputs, ArrayList outputs )		throws CGActorException	{				//Global.info( "Looking for primitive actor " + actorName );				// 1_0 actors can be enabled/disabled by preferences		if ( actorName.equalsIgnoreCase( "plus" ) ) activateArithmeticPrimitive( gu, "plus", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "minus" ) ) activateArithmeticPrimitive( gu, "minus", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "multiply" ) ) activateArithmeticPrimitive( gu, "multiply", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "divide" ) ) activateArithmeticPrimitive( gu, "divide", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "dbfind" ) ) activateLookupPrimitive( gu, "dbfind", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "lookup" ) ) activateLookupPrimitive( gu, "lookup", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "equal" ) ) activateLogicalPrimitive( gu, "equal", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "equal_1_0" ) ) activateLogicalPrimitive( gu, "equal_1_0", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "notequal" ) ) activateLogicalPrimitive( gu, "notequal", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "notequal_1_0" ) ) activateLogicalPrimitive( gu, "notequal_1_0", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "greaterthan" ) ) activateArithmeticPrimitive( gu, "greaterthan", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "greaterthan_1_0" ) ) activateArithmeticPrimitive( gu, "greaterthan_1_0", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "greaterequal" ) ) activateArithmeticPrimitive( gu, "greaterequal", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "greaterequal_1_0" ) ) activateArithmeticPrimitive( gu, "greaterequal_1_0", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "lessthan" ) ) activateArithmeticPrimitive( gu, "lessthan", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "lessthan_1_0" ) ) activateArithmeticPrimitive( gu, "lessthan_1_0", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "lessequal" ) ) activateArithmeticPrimitive( gu, "lessequal", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "lessequal_1_0" ) ) activateArithmeticPrimitive( gu, "lessequal_1_0", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "copy" ) ) activateUnaryPrimitive( gu, "copy", inputs, outputs );		else if ( actorName.equalsIgnoreCase( "exp" ) ) activateUnaryPrimitive( gu, "exp", inputs, outputs );		else Global.info( "couldn't find primitive actor " + actorName );				// here would be a good place to re-set actor to not active	}		/**		Verifies that the number of input concepts and the number of output referents for the actor matches its		definition. If they don't, throws an exception.	 */	protected static void checkInOutSize( 		int numInputs, int numOutputs, ArrayList inputs, ArrayList outputs )	throws CGActorException	{		if ( inputs.size() != numInputs || outputs.size() != numOutputs )				throw new CGActorException( "Expected " + numInputs + " input(s) and " +				numOutputs + " output(s); had " + inputs.size() + " and " + outputs.size() );		}		/**		Implements the arithmetic primitives for actors.		If any output referents have been changed, then call update		@param gu The updater whose thread should be executing our update		@param operation One of the arithmetic actor names: "plus" "minus" "multiply" "divide"; also used for				"greaterthan" "greaterequal" "lessthan" "lessequal" because they need number inputs also.		@param inputs List of GNodes which are the inputs		@param outputs List of GNodes which are the outputs		@see ActorPrimitive#performActorOperation	 */	public static void activateArithmeticPrimitive( GraphUpdater gu, String operation, ArrayList inputs, ArrayList outputs ) 		throws CGActorException	{		NumberFormat vformat = NumberFormat.getNumberInstance();		// format for the value only		vformat.setMaximumFractionDigits( 4 );		vformat.setMinimumFractionDigits( 0 );		double arg1 = 0.0;		double arg2 = 0.0;				Concept in1 = null, in2 = null;		if ( ! GraphUpdater.hasAttribute( operation, "varyingInputCardinality" ) )		{			if ( ((Concept) inputs.get( 0 )).getTypeLabel().equals( "1" ) ) 			{				in2 = (Concept) inputs.get( 1 );				in1 = (Concept) inputs.get( 0 );			}			else if ( ((Concept) inputs.get( 1 )).getTypeLabel().equals( "1" ) ) 				{				in1 = (Concept) inputs.get( 1 );				in2 = (Concept) inputs.get( 0 );			}			else // use the order they were inserted.				{				in1 = (Concept) inputs.get( 0 );				in2 = (Concept) inputs.get( 1 );							}						if ( Global.AllowNullActorArguments ) {				if ( in1.getReferent().equalsIgnoreCase( "null" ) || in1.getTypeLabel().equalsIgnoreCase( "null" ) ) return;				if ( in2.getReferent().equalsIgnoreCase( "null" ) || in2.getTypeLabel().equalsIgnoreCase( "null" ) ) return;			}						try {				arg1 = vformat.parse( in1.getReferent() ).doubleValue();					arg2 = vformat.parse( in2.getReferent() ).doubleValue();			} catch ( ParseException e )			{				throw new CGActorException( "Referent \"" + e.getMessage() + "\" is not a valid number." );			}			in1.setChanged( false );			in2.setChanged( false );		}		else		// has varying input cardinality		{//				Global.info( "has varying input cardinality" );		}		Concept out = (Concept) outputs.get( 0 );		String OldOutReferent = out.getReferent();								double result = 0.0;		boolean logicalResult = false;	// needs some default value		boolean needsLogicalResult = false;	// whether to care about logicalResult or not		boolean use_0_1 = false;	// whether to use 0/1 values or T/null values		String NewOutReferent = new String( "null" );		String workstr = null;				// these tests may be unnecessary if we've already checked all arguments for null		//if ( ! in1.getReferent().equalsIgnoreCase( "null" ) && ! in2.getReferent().equalsIgnoreCase( "null" ) )		{					// in the future, would like to adjust decimal places based on min(arg1, arg2 ) decimals			if ( operation.equalsIgnoreCase( "plus" ) )				if ( ! GraphUpdater.hasAttribute( operation,  "varyingInputCardinality" ) )					result = arg1 + arg2;				else					result = operateOnReferents( inputs, vformat, operation );			else if ( operation.equalsIgnoreCase( "minus" ) )		                                        result = arg1 - arg2;			else if ( operation.equalsIgnoreCase( "multiply" ) )				if ( ! GraphUpdater.hasAttribute( operation, "varyingInputCardinality" ) )					result = arg1 * arg2;				else					result = operateOnReferents( inputs, vformat, operation );			else if ( operation.equalsIgnoreCase( "divide" ) )	                                result = arg1 / arg2;			else		// it's one of the logical operators			{				needsLogicalResult = true;				if ( operation.equalsIgnoreCase( "greaterthan" ) ) 				{				    logicalResult = ( arg1 > arg2 );				    use_0_1 = false;				}				else if ( operation.equalsIgnoreCase( "greaterthan_1_0" ) ) 				{				    logicalResult = ( arg1 > arg2 );				    use_0_1 = true;				}				else if ( operation.equalsIgnoreCase( "greaterequal" ) )				{				    logicalResult = ( arg1 >= arg2 );				    use_0_1 = false;				}				else if ( operation.equalsIgnoreCase( "greaterequal_1_0" ) )				{				    logicalResult = ( arg1 >= arg2 );				    use_0_1 = true;				}				else if ( operation.equalsIgnoreCase( "lessthan" ) )				{				    logicalResult = ( arg1 < arg2 );				    use_0_1 = false;				}				else if ( operation.equalsIgnoreCase( "lessthan_1_0" ) )				{				    logicalResult = ( arg1 < arg2 );				    use_0_1 = true;				}				else if ( operation.equalsIgnoreCase( "lessequal" ) )				{				    logicalResult = ( arg1 <= arg2 );				    use_0_1 = false;				}				else if ( operation.equalsIgnoreCase( "lessequal_1_0" ) )				{				    logicalResult = ( arg1 <= arg2 );				    use_0_1 = true;				}			}		}		//else if ( Global.AllowNullActorArguments ) return;				if ( needsLogicalResult )		{		    if ( use_0_1 )		    {			if ( logicalResult ) workstr = new String( "1" );			else workstr = new String( "0" );		    }		    else		    {			if ( logicalResult ) workstr = new String( "T" );			else workstr = new String( "null" );		    		    }		}		else		{						workstr = vformat.format( result );			//workstr = trimDecimals( result, 4 );					// trim numeric result to four decimal places if possible					//	Global.info( "arg1 arg2 result" + arg1 + ";" + arg2 + ";" + result );		}		NewOutReferent = workstr;		out.setReferent( NewOutReferent, true );		//if ( GraphUpdater.hasAttribute( operation, "trigger" )		if ( out.isChanged()			|| (! NewOutReferent.equalsIgnoreCase( OldOutReferent )) ) 		{			if ( out.getOwnerFrame() != null )                             out.getOwnerFrame().emgr.setChangedContent( EditChange.SEMANTICS  );					// uncommented 10-05-03, to account for taking setchanged out of setreferent			gu.propagate( out );		}	}		/**	/**		Implements a set of logical primitive actors.		If any output referents have been changed, then call update		@param gu The updater whose thread should be executing our update		@param operation one of "equal", "notequal" ; numeric comparisons are in activateArithmeticPrimitive		@param inputs List of GNodes which are the inputs		@param outputs List of GNodes which are the outputs		@see ActorPrimitive#performActorOperation		Needs: a way to handle contexts here ...	 */	public static void activateLogicalPrimitive( GraphUpdater gu, String operation, ArrayList inputs, ArrayList outputs ) 			throws CGActorException	{			// 		@bug Should check for type matching.		Concept in1 = (Concept) inputs.get( 0 );		Concept in2 = (Concept) inputs.get( 1 );		String ref1 = in1.getReferent();		String ref2 = in2.getReferent();				Concept out = (Concept) outputs.get( 0 );		String OldOutType = out.getTypeLabel();		String OldOutRef = out.getReferent();				in1.setChanged( false );		in2.setChanged( false );				String NewOutType = new String( OldOutType );	// by default, don't change output type!		String NewOutRef = new String( "" );					//Global.info( "operation: " + operation + " ref1 " + ref1 + " ref2 " + ref2 );		if ( operation.equalsIgnoreCase( "equal" ) )			if (ref1.equalsIgnoreCase( ref2 ) ) 				NewOutType = new String( "T" );			else				NewOutType = new String( "null" );		else if ( operation.equalsIgnoreCase( "equal_1_0" ) )			if ( ref1.equalsIgnoreCase( ref2 ) ) 				NewOutRef = new String( "1" );			else				NewOutRef = new String( "0" );		else if ( operation.equalsIgnoreCase( "notequal" ) )			if ( ! ref1.equalsIgnoreCase( ref2 ) ) 				NewOutType = new String( "T" );			else				NewOutType = new String( "null" );		else if ( operation.equalsIgnoreCase( "notequal_1_0" ) )			if ( ! ref1.equalsIgnoreCase( ref2 ) ) 				NewOutRef = new String( "1" );			else				NewOutRef = new String( "0" );		out.setTypeLabel( NewOutType );		out.setReferent( NewOutRef, true );				//if ( GraphUpdater.hasAttribute( operation, "trigger" )		if ( out.isChanged()			|| ! NewOutType.equalsIgnoreCase( OldOutType ) 			|| ! NewOutRef.equalsIgnoreCase( OldOutRef ) ) 		{			if ( out.getOwnerFrame() != null )                             out.getOwnerFrame().emgr.setChangedContent( EditChange.SEMANTICS  );								// uncommented 10-05-03, to account for taking setchanged out of setreferent			gu.propagate( (GNode) out );		}	}		/**			@param gu The updater whose thread should be executing our update		@param operation one of "copy" "exp" 	 */	public static void activateUnaryPrimitive( GraphUpdater gu, String operation, ArrayList inputs, ArrayList outputs ) 			throws CGActorException	{		Concept in = (Concept) inputs.get( 0 );		String ref = in.getReferent();						Concept out = (Concept) outputs.get( 0 );		String OldOutRef = out.getReferent();				in.setChanged( false );				String NewOutRef = new String( "null" );		if ( operation.equalsIgnoreCase( "copy" ) ) NewOutRef = new String( ref );		else if ( operation.equalsIgnoreCase( "exp" ) )		{			double arg1 = Double.parseDouble( ref );			double argout = Math.exp( arg1 );			NewOutRef = trimDecimals( argout, 4 );		}		out.setReferent( NewOutRef, true );					Global.info( "at activate unary primitive \"" + operation + "\"; out referent is " + NewOutRef );		//if ( GraphUpdater.hasAttribute( operation, "trigger" ) || ! NewOutRef.equalsIgnoreCase( OldOutRef ) ) 		if ( out.isChanged() || ! NewOutRef.equalsIgnoreCase( OldOutRef ) ) 		{			if ( out.getOwnerFrame() != null )                             out.getOwnerFrame().emgr.setChangedContent( EditChange.SEMANTICS  );					// uncommented 10-05-03, to account for taking setchanged out of setreferent			gu.propagate( out );		}	}		/**		Implements a lookup primitive for actors.		Assumes that one input referents are symbols for a particular defined database			(really just hashtables or property lists).		If any output referent has been changed, then call update on it.		@param gu The updater whose thread should be executing our update		@param actorName should be "dbfind"		@param inputs List of GNodes which are the inputs		@param outputs List of GNodes which are the outputs		@see ActorPrimitive#performActorOperation	 */	public static void activateLookupPrimitive( GraphUpdater gu, String actorName, ArrayList inputs, ArrayList outputs )		throws CGActorException 	{				// Obtain the string referents of the input concepts		Concept dbcon, keycon;		if ( ((Concept) inputs.get( 0 )).getTypeLabel().equalsIgnoreCase( "Database" ) ) 		{			keycon = (Concept) inputs.get( 1 );			dbcon = (Concept) inputs.get( 0 );		}		else if ( ((Concept) inputs.get( 1 )).getTypeLabel().equalsIgnoreCase( "Database" ) ) 		{			dbcon = (Concept) inputs.get( 1 );			keycon = (Concept) inputs.get( 0 );		}		else throw new CGActorException( "Does not have an input concept of type 'Database'." );				// should have probably checked for null arguments				String keyvalue = keycon.getReferent();		String keytype = keycon.getTypeLabel();		String dbname = dbcon.getReferent();								// Global.info( "Performing a lookup in database " + dbname );		int keyFieldPosition;		charger.db.TextDatabase db;				try {			db = (charger.db.TextDatabase) Global.activateDatabase( Global.DatabaseFolder + File.separator + dbname );		} catch ( CGFileException fe ) 		{			dbcon.setActive( true );					// Global.info( "handling file exception on database " + dbname );			throw new CGActorException( fe.getMessage() );		}		Iterator OutConcepts = outputs.iterator();		ArrayList<GraphObject> ChangedConcepts = new ArrayList<GraphObject>();				// For each output referent, copy the result's string into it.				// if the referent has changed, add it to the ChangedConcept node list		while ( OutConcepts.hasNext() )		{					// look at the next output concept			Concept out = (Concept) OutConcepts.next();			String OldOutTypeString = out.getTypeLabel();			String OldOutRefString = out.getReferent();					// get its new referent					// Global.info( "Key type is " + keytype + ", keyvalue is " + keyvalue );			String NewOutRefString = db.doLookup( keytype, keyvalue, OldOutTypeString );					// Global.info( "found: out type is " + OldOutTypeString + ", out ref is " + NewOutRefString );			if ( NewOutRefString == null ) NewOutRefString = new String( "null" );			out.setReferent( NewOutRefString, true );			//if ( GraphUpdater.hasAttribute( actorName, "trigger" ) || 			if ( out.isChanged() || 				! NewOutRefString.equalsIgnoreCase( OldOutRefString ) ) {					if ( out.getOwnerFrame() != null )                                             out.getOwnerFrame().emgr.setChangedContent( EditChange.SEMANTICS  );						// uncommented 10-05-03, to account for taking setchanged out of setreferent					ChangedConcepts.add( out );				}				// could call updateGNode right here, but perhaps it's best to wait 'til all are done.		}		Iterator changed = ChangedConcepts.iterator();		while ( changed.hasNext() )		{			Object ob = changed.next();			gu.propagate( (GNode)ob );		}	}	/**		trims trailing decimal places (NOT rounded!)		@param result value whose decimal is to be rounded	 */	private static String trimDecimals( double result, int numDecimals )	{		String workstr = String.valueOf( result ) ;		int decimalPlace = workstr.indexOf( "." );		if ( decimalPlace >= 0 ) 		{	// there is usually a decimal point						// shortcut for integers			if ( workstr.endsWith( ".0" ) ) 				workstr = new String( workstr.substring( 0, decimalPlace  ) );			else if ( workstr.length() >= decimalPlace + numDecimals )					workstr = new String( workstr.substring( 0, decimalPlace + numDecimals + 1 ) );		}		return workstr;	}		/**		Performs operations for varying input cardinality actors.		@param inputs	The input concept to the actor		@param vformat	The numberic format to be used in parsing (or formatting) numbers		@param operation one of <code>"plus"</code> or <code>"multiply"</code> at present	 */	private static double operateOnReferents( ArrayList inputs, NumberFormat vformat, String operation )					// operation is "plus" or "multiply"				throws CGActorException	{		if ( inputs.size() <= 0 ) throw new CGActorException( "Actor \"" + operation + "\"requires at least one input. Found none." );		double result = 0;		if ( operation.equalsIgnoreCase( "multiply" ) ) result = 1;		double operand = 0;		Iterator concepts = inputs.iterator();		while ( concepts.hasNext() )		{			Concept in = (Concept) concepts.next();			try {				operand = vformat.parse( in.getReferent() ).doubleValue();			} catch ( ParseException e )			{				throw new CGActorException( "Input referent \"" + e.getMessage() + "\" to actor \"" +					operation + "\" is not a valid number." );			}			if ( operation.equalsIgnoreCase( "plus" ) )				result = result + operand;			else				result = result * operand;		}		return result;	}	}