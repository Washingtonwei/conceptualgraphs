package charger.obj;import charger.*;import charger.util.*;import java.util.*;import java.awt.*;import charger.*;/*  $Header$  *//* CharGer - Conceptual Graph Editor Copyright reserved 1998-2014 by Harry S. Delugach          This package is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. This package is  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A  PARTICULAR PURPOSE. See the GNU Lesser General Public License for more  details. You should have received a copy of the GNU Lesser General Public License along with this package; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA *//** * General iterator for graph objects. * * @author Harry S. Delugach ( delugach@uah.edu ) Copyright (c) 1998-2014 by * Harry S. Delugach. * @see GraphObject * @see Graph */abstract public class GraphObjectIterator implements Iterator {    /**     * Holds the graph objects to be examined     */    private ArrayList objectList = new ArrayList( 10 );    /**     * An indicator GraphObject type or subtype(s) being iterated     */    private GraphObject.Kind kindToMatch = GraphObject.Kind.ALL;    /**     * an indicator of whether to perform a deep or shallow iteration     */    private boolean deep = false;    /**     * Used when iterating objects of a particular class, rather than using an     * integer type indicator     */    private GraphObject GraphObjectToMatch = null; 	// used when matching a class    /**     * Collect graph objects to form an iteration. The graph itself is not     * included.     *     * @param g graph whose elements are collected to form the iteration     * @param kind one of GraphObject GRAPH, GNODE, GEDGE -- what kind of     * objects to collect. Should be zero if all objects are to be collected.     * @see GraphObject.Kind     * @param isDeep whether to recursively collect objects from nested graphs     * (true) or not     */    public GraphObjectIterator( Graph g, GraphObject go, GraphObject.Kind kind, boolean isDeep ) {        // Global.info( "starting Iterator, adding objects from graph " + g.getTextLabel() );        GraphObjectToMatch = go;        kindToMatch = kind;        deep = isDeep;        if ( g != null ) {            addGraphObjects( g );	// if g is null, then is already empty//             Global.info( "loaded GraphObjectIterator, deep is " + isDeep + ";  length is " + objectList.size() );        }					    }    /**     * Adds objects from a graph to the collection to return (in ArrayList v),     * based on GraphObjectToMatch or KindToMatch     *     * @param g the graph whose object are to be tested for whether they should     * be included or not.     */    //private synchronized void addGraphObjects( Graph g ) 	// commented 12-15-02    private void addGraphObjects( Graph g ) {        if ( g.getGraphObjectCount() == 0 ) {            return;        }        String classToMatch = null;        if ( GraphObjectToMatch != null ) {            classToMatch = CGUtil.shortClassName( GraphObjectToMatch );        }        Iterator iter = g.graphObjects();        while ( iter.hasNext() ) {            GraphObject goinst = (GraphObject)iter.next();            if ( GraphObjectToMatch != null ) {                if ( classToMatch.equals( CGUtil.shortClassName( goinst ) ) ) // 05-15-03                //if ( goinst instanceof GraphObjectToMatch.getClass() )                {                    objectList.add( goinst );                }            } else {                //Global.info( "object iterator looking at " + goinst.getClass() + " named " + goinst.getTextLabel() );                if ( ( kindToMatch == GraphObject.Kind.GNODE && ( goinst instanceof GNode ) )                        || ( kindToMatch == GraphObject.Kind.CONCEPT_OR_GRAPH                        && ( ( goinst instanceof Concept ) || ( goinst instanceof Graph ) ) )                        || ( ( kindToMatch == GraphObject.Kind.ALL ) || ( goinst.myKind == kindToMatch ) ) ) {                    objectList.add( goinst );                    //Global.info( "object iterator added " + goinst.getClass() + " named " + goinst.getTextLabel() );                }            }            //if ( goinst.myKind == GraphObject.GRAPH && deep ) {	// 05-15-03            if ( goinst instanceof Graph && deep ) {                addGraphObjects( (Graph)goinst );            }        }    }    public /*synchronized*/ boolean hasNext() {        return ( !objectList.isEmpty() );    }    public /*synchronized*/ Object next() {        Object ob = objectList.get( 0 );        objectList.remove( 0 );        //Global.info( "at nextElement, ob = " + ob.toString() );        return ob;    }    public void remove() throws UnsupportedOperationException {        throw new UnsupportedOperationException( "Remove from iterator not yet supported for CharGer." );    }        public int howMany() {        // Really shouldn't do this, but it's awfully helpful in debugging sometimes.        return objectList.size();    }}